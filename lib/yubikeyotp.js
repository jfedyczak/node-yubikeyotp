// Generated by CoffeeScript 1.7.1
(function() {
  var cmp, crc16, crypto, mh, modhexDecode, parseOTP, querystring, request, verifyOTP;

  crypto = require('crypto');

  request = require('request');

  querystring = require('querystring');

  mh = {
    'c': '0',
    'b': '1',
    'd': '2',
    'e': '3',
    'f': '4',
    'g': '5',
    'h': '6',
    'i': '7',
    'j': '8',
    'k': '9',
    'l': 'a',
    'n': 'b',
    'r': 'c',
    't': 'd',
    'u': 'e',
    'v': 'f'
  };

  crc16 = function(buf) {
    var i, j, m_crc, x, _i, _j, _len;
    m_crc = 0xffff;
    for (_i = 0, _len = buf.length; _i < _len; _i++) {
      x = buf[_i];
      m_crc ^= x;
      for (i = _j = 0; _j <= 7; i = ++_j) {
        j = m_crc & 1;
        m_crc >>= 1;
        if (j) {
          m_crc ^= 0x8408;
        }
      }
    }
    return m_crc;
  };

  modhexDecode = function(s) {
    var c, w, _i, _len;
    w = '';
    for (_i = 0, _len = s.length; _i < _len; _i++) {
      c = s[_i];
      w += mh[c];
    }
    return w;
  };

  cmp = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };

  parseOTP = function(otp, key) {
    var data, decipher, msg, pub_id, result;
    otp = /^([cbdefghiujklnrtuv]{2,32})([cbdefghiujklnrtuv]{32})$/.exec(otp);
    if (!otp) {
      return false;
    }
    key = new Buffer(key, 'hex');
    pub_id = modhexDecode(otp[1]);
    msg = modhexDecode(otp[2]);
    msg = new Buffer(msg, 'hex');
    decipher = crypto.createDecipheriv('aes-128-ecb', key, '');
    decipher.setAutoPadding(false);
    data = Buffer.concat([decipher.update(msg), decipher.final()]);
    if ((crc16(data)) !== 0xf0b8) {
      return false;
    }
    result = {
      pubUid: pub_id,
      uid: data.slice(0, 6).toString('hex'),
      useCtr: data[6] + (data[7] << 8),
      tstp: data[8] + (data[9] << 8) + (data[10] << 16),
      sessionCtr: data[11],
      rnd: data[12] + (data[13] << 8),
      crc: data[14] + (data[15] << 8)
    };
    return result;
  };

  verifyOTP = function(options, callback) {
    var h, hmac, k, keys, params, qs, requestParams, v;
    if (options.apiUrl == null) {
      options.apiUrl = "https://api.yubico.com/wsapi/2.0/verify";
    }
    if (options.requestParams == null) {
      options.requestParams = {};
    }
    if (options.timestamp == null) {
      options.timestamp = false;
    }
    if (options.sl == null) {
      options.sl = false;
    }
    if (options.timeout == null) {
      options.timeout = false;
    }
    if (options.nonce == null) {
      options.nonce = crypto.pseudoRandomBytes(24).toString('base64').replace(/[^0-9a-zA-Z]/g, '');
    }
    params = {
      id: options.id,
      nonce: options.nonce,
      otp: options.otp
    };
    if (options.timestamp) {
      params.timestamp = 1;
    }
    if (options.sl !== false) {
      params.sl = options.sl;
    }
    if (options.timeout !== false) {
      params.timeout = options.timeout;
    }
    if ('key' in options) {
      keys = ((function() {
        var _results;
        _results = [];
        for (k in params) {
          _results.push(k);
        }
        return _results;
      })()).sort(cmp);
      qs = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          k = keys[_i];
          _results.push("" + k + "=" + params[k]);
        }
        return _results;
      })()).join('&');
      hmac = crypto.createHmac('sha1', new Buffer(options.key, 'base64'));
      hmac.update(qs);
      h = hmac.digest('base64');
      h = querystring.encode(h);
      qs += "&h=" + h;
    } else {
      qs = ((function() {
        var _results;
        _results = [];
        for (k in params) {
          v = params[k];
          _results.push("" + k + "=" + v);
        }
        return _results;
      })()).join('&');
    }
    requestParams = options.requestParams;
    requestParams.uri = "" + options.apiUrl + "?" + qs;
    return request(requestParams, function(e, r, body) {
      var line, result, _i, _len, _ref, _ref1;
      if (e) {
        return callback(e);
      }
      if (!(r && (r.statusCode != null))) {
        return callback('No HTTP status code');
      }
      if (r.statusCode !== 200) {
        return callback("HTTP status code: " + r.statusCode);
      }
      result = {};
      _ref = body.trim().split("\r\n");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _ref1 = line.split("="), k = _ref1[0], v = _ref1[1];
        result[k] = v;
      }
      if (!('otp' in result)) {
        return callback('No OTP in result');
      }
      if (result.otp !== options.otp) {
        return callback('OTP mismatch');
      }
      if ('key' in options) {
        if (!('h' in result)) {
          return callback('No signature in response');
        }
        keys = ((function() {
          var _results;
          _results = [];
          for (k in result) {
            _results.push(k);
          }
          return _results;
        })()).filter(function(x) {
          return x !== 'h';
        }).sort(cmp);
        qs = ((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
            k = keys[_j];
            _results.push("" + k + "=" + result[k]);
          }
          return _results;
        })()).join('&');
        hmac = crypto.createHmac('sha1', new Buffer(options.key, 'base64'));
        hmac.update(qs);
        h = hmac.digest('base64').replace(/\=/g, '');
        if (h !== result.h) {
          return callback('Signature mismatch');
        }
      }
      return callback(null, result);
    });
  };

  module.exports = {
    parseOTP: parseOTP,
    verifyOTP: verifyOTP
  };

}).call(this);
